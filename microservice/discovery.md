## 상황
- 프론트엔드가 여러개의 micro service 를 어떻게 호출할까 ?
- 스케일 아웃을 통해 만약 인스턴스가 여러개로 복제됐을 때는 어떻게 할까 ?


### Service discovery pattern
- 클라이언트가 여러개의 마이크로 서비스를 호출하기 위해, 적절히 최적경로를 찾아주는 라우팅 기능,  부하 분산을 위한 로드밸런싱 기능 제공이 필요
ex) 넷플릭스의 라우팅 기능은 zuul, 로드밸런싱 기능은 리본이 담당함
- 라우터는 최적 경로 탐색을 위한 ip가 필요한데 라우팅 정보를 클라이언트가 가지고 있으면 동적으로 변경되는 유동 ip 정보에 따라 변경해야함
- 따라서 마이크로 서비스의 명칭과 유동적인 ip 매핑해서 보관할 저장소 넷플릭스 oss의 유레카(Eureka)가 담당하고, 이러한 패턴을 서비스 레지스트리 패턴이라고 한다.


![스크린샷 2024-04-08 오후 1 23 29](https://github.com/yunhwane/playground/assets/147581818/70d3c358-e03a-424d-8edc-94813c8ec563)

- 모든 마이크로서비스가 처음 기동될 때 위치정보저장 후 서비스가 종료될때 삭제됨
>> 쿠버네티스의 경우 레지스트리, 디스커버리 기능 자체 기능인 쿠버네티스 dns 및 쿠버네티스 서비스 제공함


### API Gateway pattern

여러 클라이언트가 여러개의 서비스를 각각 호출한다면 매우 복잡한 호출관계가 될 것이다. 
클라이언트가 다양한 서비스에 접근하기 위함이고, 정삭적으로 동작하던 서비스에 문제 발생 시 정상적인 다른 서비스로 요청 경로를 벗어나도록 처리할 수 있는 기능도 만들 수 있다.
![스크린샷 2024-04-08 오후 1 38 15](https://github.com/yunhwane/playground/assets/147581818/496d1ee5-34e7-4ddb-8eb7-2773caa0063f)

1. 레지스트리 서비스와 연계한 동적라우팅, 로드밸런싱
2. 인증/인가
3. 로깅
4. 메트릭
5. 로깅추적
6. 모니터링 서비스와 연계한 장애 격리(서킷 브레이커 패턴) 등


### 외부 구성 저장소 패턴(config)

#### Twelve-Factor
- 어플리케이션이 배포되는 환경(스테이징, 프로덕션, 개발, 테스트환경) 이 매번 달라지기 때문에 환경 설정 정보는 어플리케이션과 독립적으로 관리해야한다는 원칙
- spring cloud config를 이용하면 환경 정보를 코드에서 분리하고, 컨피그 서비스를 통하여 런타임시 주입되게 처리할 수 있다.
- 별도의 형상관리 레포에 보관하여 특정 환경에 배포될때 적절한 환경 정보를 리포지토리에서 가져와 서비스에 주입시킴
>> 쿠버네티스 ConfigMap으로 제공함
